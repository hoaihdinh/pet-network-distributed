// microservices/proto/pet_network.proto

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.1
// source: pet_network.proto

package petnetwork

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ReportService_CreateReport_FullMethodName = "/petnetwork.ReportService/CreateReport"
	ReportService_GetReport_FullMethodName    = "/petnetwork.ReportService/GetReport"
	ReportService_ListReports_FullMethodName  = "/petnetwork.ReportService/ListReports"
)

// ReportServiceClient is the client API for ReportService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ========================================
// Report Service - FR1: Create Lost/Found Report
// ========================================
type ReportServiceClient interface {
	CreateReport(ctx context.Context, in *CreateReportRequest, opts ...grpc.CallOption) (*CreateReportResponse, error)
	GetReport(ctx context.Context, in *GetReportRequest, opts ...grpc.CallOption) (*Report, error)
	ListReports(ctx context.Context, in *ListReportsRequest, opts ...grpc.CallOption) (*ListReportsResponse, error)
}

type reportServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewReportServiceClient(cc grpc.ClientConnInterface) ReportServiceClient {
	return &reportServiceClient{cc}
}

func (c *reportServiceClient) CreateReport(ctx context.Context, in *CreateReportRequest, opts ...grpc.CallOption) (*CreateReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateReportResponse)
	err := c.cc.Invoke(ctx, ReportService_CreateReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportServiceClient) GetReport(ctx context.Context, in *GetReportRequest, opts ...grpc.CallOption) (*Report, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Report)
	err := c.cc.Invoke(ctx, ReportService_GetReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportServiceClient) ListReports(ctx context.Context, in *ListReportsRequest, opts ...grpc.CallOption) (*ListReportsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListReportsResponse)
	err := c.cc.Invoke(ctx, ReportService_ListReports_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReportServiceServer is the server API for ReportService service.
// All implementations must embed UnimplementedReportServiceServer
// for forward compatibility.
//
// ========================================
// Report Service - FR1: Create Lost/Found Report
// ========================================
type ReportServiceServer interface {
	CreateReport(context.Context, *CreateReportRequest) (*CreateReportResponse, error)
	GetReport(context.Context, *GetReportRequest) (*Report, error)
	ListReports(context.Context, *ListReportsRequest) (*ListReportsResponse, error)
	mustEmbedUnimplementedReportServiceServer()
}

// UnimplementedReportServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedReportServiceServer struct{}

func (UnimplementedReportServiceServer) CreateReport(context.Context, *CreateReportRequest) (*CreateReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateReport not implemented")
}
func (UnimplementedReportServiceServer) GetReport(context.Context, *GetReportRequest) (*Report, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReport not implemented")
}
func (UnimplementedReportServiceServer) ListReports(context.Context, *ListReportsRequest) (*ListReportsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReports not implemented")
}
func (UnimplementedReportServiceServer) mustEmbedUnimplementedReportServiceServer() {}
func (UnimplementedReportServiceServer) testEmbeddedByValue()                       {}

// UnsafeReportServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReportServiceServer will
// result in compilation errors.
type UnsafeReportServiceServer interface {
	mustEmbedUnimplementedReportServiceServer()
}

func RegisterReportServiceServer(s grpc.ServiceRegistrar, srv ReportServiceServer) {
	// If the following call pancis, it indicates UnimplementedReportServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ReportService_ServiceDesc, srv)
}

func _ReportService_CreateReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).CreateReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReportService_CreateReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).CreateReport(ctx, req.(*CreateReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReportService_GetReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).GetReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReportService_GetReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).GetReport(ctx, req.(*GetReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReportService_ListReports_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReportsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).ListReports(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReportService_ListReports_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).ListReports(ctx, req.(*ListReportsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReportService_ServiceDesc is the grpc.ServiceDesc for ReportService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReportService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "petnetwork.ReportService",
	HandlerType: (*ReportServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateReport",
			Handler:    _ReportService_CreateReport_Handler,
		},
		{
			MethodName: "GetReport",
			Handler:    _ReportService_GetReport_Handler,
		},
		{
			MethodName: "ListReports",
			Handler:    _ReportService_ListReports_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pet_network.proto",
}

const (
	MatchingService_FindMatches_FullMethodName         = "/petnetwork.MatchingService/FindMatches"
	MatchingService_CalculateMatchScore_FullMethodName = "/petnetwork.MatchingService/CalculateMatchScore"
)

// MatchingServiceClient is the client API for MatchingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ========================================
// Matching Service - FR4: Distributed Match Query
// ========================================
type MatchingServiceClient interface {
	FindMatches(ctx context.Context, in *FindMatchesRequest, opts ...grpc.CallOption) (*FindMatchesResponse, error)
	CalculateMatchScore(ctx context.Context, in *MatchScoreRequest, opts ...grpc.CallOption) (*MatchScoreResponse, error)
}

type matchingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMatchingServiceClient(cc grpc.ClientConnInterface) MatchingServiceClient {
	return &matchingServiceClient{cc}
}

func (c *matchingServiceClient) FindMatches(ctx context.Context, in *FindMatchesRequest, opts ...grpc.CallOption) (*FindMatchesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindMatchesResponse)
	err := c.cc.Invoke(ctx, MatchingService_FindMatches_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *matchingServiceClient) CalculateMatchScore(ctx context.Context, in *MatchScoreRequest, opts ...grpc.CallOption) (*MatchScoreResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MatchScoreResponse)
	err := c.cc.Invoke(ctx, MatchingService_CalculateMatchScore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MatchingServiceServer is the server API for MatchingService service.
// All implementations must embed UnimplementedMatchingServiceServer
// for forward compatibility.
//
// ========================================
// Matching Service - FR4: Distributed Match Query
// ========================================
type MatchingServiceServer interface {
	FindMatches(context.Context, *FindMatchesRequest) (*FindMatchesResponse, error)
	CalculateMatchScore(context.Context, *MatchScoreRequest) (*MatchScoreResponse, error)
	mustEmbedUnimplementedMatchingServiceServer()
}

// UnimplementedMatchingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMatchingServiceServer struct{}

func (UnimplementedMatchingServiceServer) FindMatches(context.Context, *FindMatchesRequest) (*FindMatchesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindMatches not implemented")
}
func (UnimplementedMatchingServiceServer) CalculateMatchScore(context.Context, *MatchScoreRequest) (*MatchScoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CalculateMatchScore not implemented")
}
func (UnimplementedMatchingServiceServer) mustEmbedUnimplementedMatchingServiceServer() {}
func (UnimplementedMatchingServiceServer) testEmbeddedByValue()                         {}

// UnsafeMatchingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MatchingServiceServer will
// result in compilation errors.
type UnsafeMatchingServiceServer interface {
	mustEmbedUnimplementedMatchingServiceServer()
}

func RegisterMatchingServiceServer(s grpc.ServiceRegistrar, srv MatchingServiceServer) {
	// If the following call pancis, it indicates UnimplementedMatchingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MatchingService_ServiceDesc, srv)
}

func _MatchingService_FindMatches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindMatchesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchingServiceServer).FindMatches(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MatchingService_FindMatches_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchingServiceServer).FindMatches(ctx, req.(*FindMatchesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MatchingService_CalculateMatchScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchScoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MatchingServiceServer).CalculateMatchScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MatchingService_CalculateMatchScore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MatchingServiceServer).CalculateMatchScore(ctx, req.(*MatchScoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MatchingService_ServiceDesc is the grpc.ServiceDesc for MatchingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MatchingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "petnetwork.MatchingService",
	HandlerType: (*MatchingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FindMatches",
			Handler:    _MatchingService_FindMatches_Handler,
		},
		{
			MethodName: "CalculateMatchScore",
			Handler:    _MatchingService_CalculateMatchScore_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pet_network.proto",
}

const (
	GeoService_NearbySearch_FullMethodName  = "/petnetwork.GeoService/NearbySearch"
	GeoService_IndexLocation_FullMethodName = "/petnetwork.GeoService/IndexLocation"
)

// GeoServiceClient is the client API for GeoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ========================================
// Geo Service - FR2: Nearby Match Search
// ========================================
type GeoServiceClient interface {
	NearbySearch(ctx context.Context, in *NearbySearchRequest, opts ...grpc.CallOption) (*NearbySearchResponse, error)
	IndexLocation(ctx context.Context, in *IndexLocationRequest, opts ...grpc.CallOption) (*IndexLocationResponse, error)
}

type geoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGeoServiceClient(cc grpc.ClientConnInterface) GeoServiceClient {
	return &geoServiceClient{cc}
}

func (c *geoServiceClient) NearbySearch(ctx context.Context, in *NearbySearchRequest, opts ...grpc.CallOption) (*NearbySearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NearbySearchResponse)
	err := c.cc.Invoke(ctx, GeoService_NearbySearch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoServiceClient) IndexLocation(ctx context.Context, in *IndexLocationRequest, opts ...grpc.CallOption) (*IndexLocationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IndexLocationResponse)
	err := c.cc.Invoke(ctx, GeoService_IndexLocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GeoServiceServer is the server API for GeoService service.
// All implementations must embed UnimplementedGeoServiceServer
// for forward compatibility.
//
// ========================================
// Geo Service - FR2: Nearby Match Search
// ========================================
type GeoServiceServer interface {
	NearbySearch(context.Context, *NearbySearchRequest) (*NearbySearchResponse, error)
	IndexLocation(context.Context, *IndexLocationRequest) (*IndexLocationResponse, error)
	mustEmbedUnimplementedGeoServiceServer()
}

// UnimplementedGeoServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGeoServiceServer struct{}

func (UnimplementedGeoServiceServer) NearbySearch(context.Context, *NearbySearchRequest) (*NearbySearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NearbySearch not implemented")
}
func (UnimplementedGeoServiceServer) IndexLocation(context.Context, *IndexLocationRequest) (*IndexLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IndexLocation not implemented")
}
func (UnimplementedGeoServiceServer) mustEmbedUnimplementedGeoServiceServer() {}
func (UnimplementedGeoServiceServer) testEmbeddedByValue()                    {}

// UnsafeGeoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GeoServiceServer will
// result in compilation errors.
type UnsafeGeoServiceServer interface {
	mustEmbedUnimplementedGeoServiceServer()
}

func RegisterGeoServiceServer(s grpc.ServiceRegistrar, srv GeoServiceServer) {
	// If the following call pancis, it indicates UnimplementedGeoServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GeoService_ServiceDesc, srv)
}

func _GeoService_NearbySearch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NearbySearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServiceServer).NearbySearch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GeoService_NearbySearch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServiceServer).NearbySearch(ctx, req.(*NearbySearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeoService_IndexLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServiceServer).IndexLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GeoService_IndexLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServiceServer).IndexLocation(ctx, req.(*IndexLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GeoService_ServiceDesc is the grpc.ServiceDesc for GeoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GeoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "petnetwork.GeoService",
	HandlerType: (*GeoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NearbySearch",
			Handler:    _GeoService_NearbySearch_Handler,
		},
		{
			MethodName: "IndexLocation",
			Handler:    _GeoService_IndexLocation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pet_network.proto",
}

const (
	AlertService_Subscribe_FullMethodName    = "/petnetwork.AlertService/Subscribe"
	AlertService_Unsubscribe_FullMethodName  = "/petnetwork.AlertService/Unsubscribe"
	AlertService_PublishAlert_FullMethodName = "/petnetwork.AlertService/PublishAlert"
)

// AlertServiceClient is the client API for AlertService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ========================================
// Alert Service - FR3: Real-Time Geo Alerts
// ========================================
type AlertServiceClient interface {
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Alert], error)
	Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error)
	PublishAlert(ctx context.Context, in *PublishAlertRequest, opts ...grpc.CallOption) (*PublishAlertResponse, error)
}

type alertServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAlertServiceClient(cc grpc.ClientConnInterface) AlertServiceClient {
	return &alertServiceClient{cc}
}

func (c *alertServiceClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Alert], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AlertService_ServiceDesc.Streams[0], AlertService_Subscribe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeRequest, Alert]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AlertService_SubscribeClient = grpc.ServerStreamingClient[Alert]

func (c *alertServiceClient) Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnsubscribeResponse)
	err := c.cc.Invoke(ctx, AlertService_Unsubscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertServiceClient) PublishAlert(ctx context.Context, in *PublishAlertRequest, opts ...grpc.CallOption) (*PublishAlertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishAlertResponse)
	err := c.cc.Invoke(ctx, AlertService_PublishAlert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AlertServiceServer is the server API for AlertService service.
// All implementations must embed UnimplementedAlertServiceServer
// for forward compatibility.
//
// ========================================
// Alert Service - FR3: Real-Time Geo Alerts
// ========================================
type AlertServiceServer interface {
	Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[Alert]) error
	Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error)
	PublishAlert(context.Context, *PublishAlertRequest) (*PublishAlertResponse, error)
	mustEmbedUnimplementedAlertServiceServer()
}

// UnimplementedAlertServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAlertServiceServer struct{}

func (UnimplementedAlertServiceServer) Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[Alert]) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedAlertServiceServer) Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unsubscribe not implemented")
}
func (UnimplementedAlertServiceServer) PublishAlert(context.Context, *PublishAlertRequest) (*PublishAlertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishAlert not implemented")
}
func (UnimplementedAlertServiceServer) mustEmbedUnimplementedAlertServiceServer() {}
func (UnimplementedAlertServiceServer) testEmbeddedByValue()                      {}

// UnsafeAlertServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AlertServiceServer will
// result in compilation errors.
type UnsafeAlertServiceServer interface {
	mustEmbedUnimplementedAlertServiceServer()
}

func RegisterAlertServiceServer(s grpc.ServiceRegistrar, srv AlertServiceServer) {
	// If the following call pancis, it indicates UnimplementedAlertServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AlertService_ServiceDesc, srv)
}

func _AlertService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AlertServiceServer).Subscribe(m, &grpc.GenericServerStream[SubscribeRequest, Alert]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AlertService_SubscribeServer = grpc.ServerStreamingServer[Alert]

func _AlertService_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertServiceServer).Unsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AlertService_Unsubscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertServiceServer).Unsubscribe(ctx, req.(*UnsubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertService_PublishAlert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishAlertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertServiceServer).PublishAlert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AlertService_PublishAlert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertServiceServer).PublishAlert(ctx, req.(*PublishAlertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AlertService_ServiceDesc is the grpc.ServiceDesc for AlertService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AlertService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "petnetwork.AlertService",
	HandlerType: (*AlertServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Unsubscribe",
			Handler:    _AlertService_Unsubscribe_Handler,
		},
		{
			MethodName: "PublishAlert",
			Handler:    _AlertService_PublishAlert_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _AlertService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pet_network.proto",
}

const (
	ReplicationService_SyncData_FullMethodName        = "/petnetwork.ReplicationService/SyncData"
	ReplicationService_ResolveConflict_FullMethodName = "/petnetwork.ReplicationService/ResolveConflict"
)

// ReplicationServiceClient is the client API for ReplicationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ========================================
// Replication Service - FR5: Cross-Region Replication
// ========================================
type ReplicationServiceClient interface {
	SyncData(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SyncDataRequest, SyncDataResponse], error)
	ResolveConflict(ctx context.Context, in *ConflictResolutionRequest, opts ...grpc.CallOption) (*ConflictResolutionResponse, error)
}

type replicationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewReplicationServiceClient(cc grpc.ClientConnInterface) ReplicationServiceClient {
	return &replicationServiceClient{cc}
}

func (c *replicationServiceClient) SyncData(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SyncDataRequest, SyncDataResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ReplicationService_ServiceDesc.Streams[0], ReplicationService_SyncData_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SyncDataRequest, SyncDataResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ReplicationService_SyncDataClient = grpc.BidiStreamingClient[SyncDataRequest, SyncDataResponse]

func (c *replicationServiceClient) ResolveConflict(ctx context.Context, in *ConflictResolutionRequest, opts ...grpc.CallOption) (*ConflictResolutionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConflictResolutionResponse)
	err := c.cc.Invoke(ctx, ReplicationService_ResolveConflict_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReplicationServiceServer is the server API for ReplicationService service.
// All implementations must embed UnimplementedReplicationServiceServer
// for forward compatibility.
//
// ========================================
// Replication Service - FR5: Cross-Region Replication
// ========================================
type ReplicationServiceServer interface {
	SyncData(grpc.BidiStreamingServer[SyncDataRequest, SyncDataResponse]) error
	ResolveConflict(context.Context, *ConflictResolutionRequest) (*ConflictResolutionResponse, error)
	mustEmbedUnimplementedReplicationServiceServer()
}

// UnimplementedReplicationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedReplicationServiceServer struct{}

func (UnimplementedReplicationServiceServer) SyncData(grpc.BidiStreamingServer[SyncDataRequest, SyncDataResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SyncData not implemented")
}
func (UnimplementedReplicationServiceServer) ResolveConflict(context.Context, *ConflictResolutionRequest) (*ConflictResolutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveConflict not implemented")
}
func (UnimplementedReplicationServiceServer) mustEmbedUnimplementedReplicationServiceServer() {}
func (UnimplementedReplicationServiceServer) testEmbeddedByValue()                            {}

// UnsafeReplicationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReplicationServiceServer will
// result in compilation errors.
type UnsafeReplicationServiceServer interface {
	mustEmbedUnimplementedReplicationServiceServer()
}

func RegisterReplicationServiceServer(s grpc.ServiceRegistrar, srv ReplicationServiceServer) {
	// If the following call pancis, it indicates UnimplementedReplicationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ReplicationService_ServiceDesc, srv)
}

func _ReplicationService_SyncData_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ReplicationServiceServer).SyncData(&grpc.GenericServerStream[SyncDataRequest, SyncDataResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ReplicationService_SyncDataServer = grpc.BidiStreamingServer[SyncDataRequest, SyncDataResponse]

func _ReplicationService_ResolveConflict_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConflictResolutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationServiceServer).ResolveConflict(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplicationService_ResolveConflict_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationServiceServer).ResolveConflict(ctx, req.(*ConflictResolutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReplicationService_ServiceDesc is the grpc.ServiceDesc for ReplicationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReplicationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "petnetwork.ReplicationService",
	HandlerType: (*ReplicationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResolveConflict",
			Handler:    _ReplicationService_ResolveConflict_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SyncData",
			Handler:       _ReplicationService_SyncData_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pet_network.proto",
}
